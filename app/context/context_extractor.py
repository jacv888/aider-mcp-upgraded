"""
Context Extractor for Context-Aware File Pruning

This module generates the final focused context from selected code blocks,
ensuring proper formatting and syntactic validity.
"""

from typing import List
from .types import ContextBlock, ExtractionConfig


class ContextExtractor:
    """
    Generates focused context from selected code blocks
    
    Ensures the output is:
    - Syntactically valid
    - Properly formatted
    - Logically ordered
    - Minimal but complete
    """
    
    def generate_focused_context(
        self, 
        selected_blocks: List[ContextBlock], 
        original_source: str,
        config: ExtractionConfig
    ) -> str:
        """Generate focused context from selected blocks"""
        
        if not selected_blocks:
            return "# No relevant context found\n"
        
        # Sort blocks by line number to maintain logical order
        sorted_blocks = sorted(selected_blocks, key=lambda x: x.start_line)
        
        # Group blocks by type for better organization
        organized_blocks = self._organize_blocks_by_type(sorted_blocks)
        
        # Generate focused content
        context_parts = []
        
        # Add header comment
        context_parts.append(self._generate_header_comment(organized_blocks, config))
        
        # Add imports first
        if 'import' in organized_blocks:
            context_parts.append("# === IMPORTS ===")
            for block in organized_blocks['import']:
                context_parts.append(block.content.strip())
            context_parts.append("")
        
        # Add type definitions
        if 'interface' in organized_blocks or 'type' in organized_blocks:
            context_parts.append("# === TYPE DEFINITIONS ===")
            for block_type in ['interface', 'type']:
                if block_type in organized_blocks:
                    for block in organized_blocks[block_type]:
                        context_parts.append(block.content.strip())
                        context_parts.append("")
        
        # Add classes (with minimal structure)
        if 'class' in organized_blocks or 'class_header' in organized_blocks:
            context_parts.append("# === CLASSES ===")
            for block_type in ['class_header', 'class']:
                if block_type in organized_blocks:
                    for block in organized_blocks[block_type]:
                        context_parts.append(block.content.strip())
                        context_parts.append("")
        
        # Add functions
        if 'function' in organized_blocks or 'method' in organized_blocks:
            context_parts.append("# === FUNCTIONS ===")
            for block_type in ['function', 'method']:
                if block_type in organized_blocks:
                    for block in organized_blocks[block_type]:
                        context_parts.append(f"# Function: {block.element_name} (lines {block.start_line}-{block.end_line})")
                        context_parts.append(block.content.strip())
                        context_parts.append("")
        
        # Add variables
        if 'variable' in organized_blocks:
            context_parts.append("# === VARIABLES ===")
            for block in organized_blocks['variable']:
                context_parts.append(block.content.strip())
        
        # Join all parts
        focused_context = '\n'.join(context_parts)
        
        # Clean up extra whitespace
        focused_context = self._clean_whitespace(focused_context)
        
        return focused_context
    
    def _organize_blocks_by_type(self, blocks: List[ContextBlock]) -> dict:
        """Organize blocks by their type for better structure"""
        organized = {}
        
        for block in blocks:
            block_type = block.element_type
            if block_type not in organized:
                organized[block_type] = []
            organized[block_type].append(block)
        
        return organized
    
    def _generate_header_comment(self, organized_blocks: dict, config: ExtractionConfig) -> str:
        """Generate informative header comment"""
        total_blocks = sum(len(blocks) for blocks in organized_blocks.values())
        block_types = list(organized_blocks.keys())
        
        header = f"""# === FOCUSED CONTEXT ===
# Token Budget: {config.max_tokens}
# Blocks Included: {total_blocks}
# Types: {', '.join(block_types)}
# Generated by Context-Aware File Pruning
"""
        return header
    
    def _clean_whitespace(self, content: str) -> str:
        """Clean up excessive whitespace while preserving code structure"""
        lines = content.split('\n')
        cleaned_lines = []
        
        prev_empty = False
        for line in lines:
            is_empty = line.strip() == ''
            
            # Avoid multiple consecutive empty lines
            if is_empty and prev_empty:
                continue
                
            cleaned_lines.append(line)
            prev_empty = is_empty
        
        # Remove trailing empty lines
        while cleaned_lines and cleaned_lines[-1].strip() == '':
            cleaned_lines.pop()
        
        return '\n'.join(cleaned_lines)
